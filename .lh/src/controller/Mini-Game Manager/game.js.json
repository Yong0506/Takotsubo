{
    "sourceFile": "src/controller/Mini-Game Manager/game.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1747064543914,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1747064543914,
            "name": "Commit-0",
            "content": "// This file contains the game logic for the maze game. It initializes the maze, handles keyboard input for player movement, manages trigger points, and displays pop-up pages when the player touches a trigger point.\r\n\r\nconst mazeContainer = document.getElementById('maze');\r\nconst mazeSize = 20;\r\nconst maze = [];\r\nconst player = { x: 0, y: 0 }; // Player's starting position\r\nlet previousPlayerPos = { x: 0, y: 0 }; // Stores player's position before a move to a trigger\r\nconst triggers = [];\r\nlet firstTriggerActivated = false; // Track if the first trigger has been activated\r\nlet triggersRemaining = 10; // Track the number of remaining trigger points\r\nlet lastReachableCell = { x: 0, y: 0 }; // Track the last reachable cell\r\nlet currentTriggerIndex = 0; // Track how many triggers have been activated\r\nlet redEndpointGenerated = false; // Track if the red endpoint has been generated\r\nlet playerHealth = 3; // Initialize player health\r\nconst deviceId = localStorage.getItem(\"deviceId\");\r\nlet isScenarioPopupActive = false; // Flag to track if a scenario popup is active\r\n\r\n\r\n// Generate the maze grid with a single path\r\nfunction generateMaze() {\r\n    function carvePath(x, y) {\r\n        visited[y][x] = true;\r\n        maze[y][x].classList.remove('wall'); // Clear the current cell\r\n\r\n        // Shuffle directions to create a random path\r\n        const shuffledDirections = directions.sort(() => Math.random() - 0.5);\r\n\r\n        for (const { dx, dy } of shuffledDirections) {\r\n            const nx = x + dx * 2;\r\n            const ny = y + dy * 2;\r\n\r\n            if (nx >= 0 && nx < mazeSize && ny >= 0 && ny < mazeSize && !visited[ny][nx]) {\r\n                // Remove the wall between the current cell and the next cell\r\n                maze[y + dy][x + dx].classList.remove('wall');\r\n                carvePath(nx, ny);\r\n            }\r\n        }\r\n\r\n        // Update the last reachable cell\r\n        lastReachableCell.x = x;\r\n        lastReachableCell.y = y;\r\n    }\r\n\r\n    // Initialize the maze with walls\r\n    for (let y = 0; y < mazeSize; y++) {\r\n        const row = [];\r\n        for (let x = 0; x < mazeSize; x++) {\r\n            const cell = document.createElement('div');\r\n            cell.classList.add('cell', 'wall'); // Start with all walls\r\n            mazeContainer.appendChild(cell);\r\n            row.push(cell);\r\n        }\r\n        maze.push(row);\r\n    }\r\n\r\n    // Create a visited array to track carved paths\r\n    const visited = Array.from({ length: mazeSize }, () => Array(mazeSize).fill(false));\r\n    const directions = [\r\n        { dx: 0, dy: -1 }, // Up\r\n        { dx: 0, dy: 1 },  // Down\r\n        { dx: -1, dy: 0 }, // Left\r\n        { dx: 1, dy: 0 }   // Right\r\n    ];\r\n\r\n    // Start carving the path from the top-left corner\r\n    carvePath(0, 0);\r\n\r\n    // Place the player at the starting point\r\n    maze[player.y][player.x].classList.add('player');\r\n\r\n    // Place 10 trigger points along the path\r\n    for (let i = 0; i < 10; i++) {\r\n        let tx, ty;\r\n        do {\r\n            tx = Math.floor(Math.random() * mazeSize);\r\n            ty = Math.floor(Math.random() * mazeSize);\r\n        } while (maze[ty][tx].classList.contains('wall') || maze[ty][tx].classList.contains('trigger') || (tx === 0 && ty === 0));\r\n        maze[ty][tx].classList.add('trigger');\r\n        triggers.push({ x: tx, y: ty });\r\n    }\r\n}\r\n\r\n// Move the player\r\nasync function movePlayer(dx, dy) {\r\n    const newX = player.x + dx;\r\n    const newY = player.y + dy;\r\n\r\n    // Store current position as previous before making the move\r\n    previousPlayerPos.x = player.x;\r\n    previousPlayerPos.y = player.y;\r\n\r\n    if (newX < 0 || newX >= mazeSize || newY < 0 || newY >= mazeSize) return; // Out of bounds\r\n    if (maze[newY][newX].classList.contains('wall')) return; // Hit a wall\r\n\r\n    // Remove player from current position\r\n    maze[player.y][player.x].classList.remove('player');\r\n\r\n    // Update player position\r\n    player.x = newX;\r\n    player.y = newY;\r\n\r\n    // Add player to new position\r\n    maze[player.y][player.x].classList.add('player');\r\n\r\n    // Check if the player reaches a trigger point\r\n    if (maze[player.y][player.x].classList.contains('trigger')) {\r\n        maze[player.y][player.x].classList.remove('trigger'); // Remove the trigger point\r\n\r\n        // Open the corresponding scenario modal\r\n        currentTriggerIndex++;\r\n        if (currentTriggerIndex <= 10) {\r\n            openModal(`scenario${currentTriggerIndex}`);\r\n        }\r\n\r\n        // Check if all triggers are activated\r\n        if (currentTriggerIndex === 10 && !redEndpointGenerated) {\r\n            generateRedEndpoint();\r\n        }\r\n    }\r\n\r\n    // Check if the player reaches the red endpoint\r\n    if (maze[player.y][player.x].classList.contains('red-end')) {\r\n        alert('🎉 Congratulations! You have completed the maze!');\r\n        try {\r\n            await db.collection('players').doc(deviceId).update({\r\n                allChapUnlock: \"Yes\"\r\n            });\r\n            localStorage.setItem(\"gameSavedDialog\", \"\");\r\n            localStorage.setItem(\"currentStory\", \"\");\r\n            window.location.href = 'partnerpairing.html';\r\n        } catch (error) {\r\n            console.error(`Error:`, error);\r\n        }\r\n        maze[player.y][player.x].classList.remove('red-end'); // Remove the red endpoint\r\n    }\r\n}\r\n\r\n// Function to generate the red endpoint\r\nfunction generateRedEndpoint() {\r\n    let ex, ey;\r\n    do {\r\n        ex = Math.floor(Math.random() * mazeSize);\r\n        ey = Math.floor(Math.random() * mazeSize);\r\n    } while (maze[ey][ex].classList.contains('wall') || maze[ey][ex].classList.contains('player'));\r\n\r\n    maze[ey][ex].classList.add('red-end'); // Add the red endpoint class\r\n    redEndpointGenerated = true;\r\n\r\n    alert('🎯 The red endpoint wil be generate after answering the last scenario! Move your player icon to trigger it and complete the maze!');\r\n}\r\n\r\n// Function to handle health loss\r\nfunction loseHealth() {\r\n    if (playerHealth > 0) {\r\n        playerHealth--;\r\n        updateHeartDisplay();\r\n\r\n        if (playerHealth <= 0) {\r\n            gameOver();\r\n        }\r\n    }\r\n}\r\n\r\n// Function to update heart display\r\nfunction updateHeartDisplay() {\r\n    for (let i = 1; i <= 3; i++) {\r\n        const heartElement = document.getElementById(`heart${i}`); // Assumes heart IDs are heart1, heart2, heart3\r\n        if (heartElement) {\r\n            if (i <= playerHealth) {\r\n                heartElement.style.visibility = 'visible';\r\n            } else {\r\n                heartElement.style.visibility = 'hidden';\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Function to handle game over\r\nfunction gameOver() {\r\n    openModal('gameOverModal'); // Assumes a modal with id=\"gameOverModal\" exists in HTML\r\n    // Optionally, disable player movement here\r\n}\r\n\r\n// Function to reset the game (called by replay button in gameOverModal)\r\nfunction resetGame() {\r\n    location.reload(); // Reload the page to reset the game to its initial state\r\n}\r\n\r\n// Modify the `showFeedback` function to handle wrong answers and health\r\nfunction showFeedback(correct, feedbackId) {\r\n    const feedback = document.getElementById(feedbackId);\r\n    const scenarioModalId = feedbackId.replace('feedback', 'scenario');\r\n\r\n    if (correct) {\r\n        feedback.innerText = \"✅ That's the right answer! Returning to the maze...\";\r\n        setTimeout(() => {\r\n            closeModal(scenarioModalId);\r\n        }, 2000); // Wait 2 seconds before closing the modal\r\n    } else {\r\n        feedback.innerText = \"❌ Incorrect! You lose a heart and will be moved back.\";\r\n        loseHealth(); // Handles health reduction and checks for game over\r\n        setTimeout(() => {\r\n            closeModal(scenarioModalId);\r\n            if (playerHealth > 0) { // If game is not over, move player back\r\n                maze[player.y][player.x].classList.remove('player'); // Remove player from current (trigger) cell\r\n                player.x = previousPlayerPos.x;\r\n                player.y = previousPlayerPos.y;\r\n                maze[player.y][player.x].classList.add('player'); // Add player to the actual previous cell\r\n            }\r\n        }, 2000); // Close modal, then move player if applicable\r\n    }\r\n}\r\n\r\n// Function to open a modal\r\nfunction openModal(id) {\r\n    document.getElementById(id).style.display = 'flex';\r\n    if (id.startsWith('scenario')) {\r\n        isScenarioPopupActive = true;\r\n    }\r\n}\r\n\r\n// Function to close a modal\r\nfunction closeModal(id) {\r\n    document.getElementById(id).style.display = 'none';\r\n    if (id.startsWith('scenario')) {\r\n        isScenarioPopupActive = false;\r\n    }\r\n}\r\n\r\n// Handle keyboard input\r\ndocument.addEventListener('keydown', (event) => {\r\n    if (isScenarioPopupActive) return; // If a scenario popup is active, do not process movement\r\n    switch (event.key) {\r\n        case 'ArrowUp':\r\n            movePlayer(0, -1);\r\n            break;\r\n        case 'ArrowDown':\r\n            movePlayer(0, 1);\r\n            break;\r\n        case 'ArrowLeft':\r\n            movePlayer(-1, 0);\r\n            break;\r\n        case 'ArrowRight':\r\n            movePlayer(1, 0);\r\n            break;\r\n    }\r\n});\r\n\r\n const choiceButtons = document.querySelectorAll(`#${modalId} .choice button`);\r\n    choiceButtons.forEach(button => button.disabled = true);\r\n\r\n    // Check if all scenarios are now completed\r\n    if (scenarioPoints.every(p => p.triggered)) {\r\n        allScenariosCompleted = true;\r\n    }\r\n\r\nfunction openInfoModal() {\r\n    document.getElementById('info-modal').style.display = 'block';\r\n}\r\n\r\nfunction closeInfoModal() {\r\n    document.getElementById('info-modal').style.display = 'none';\r\n}\r\n\r\n// Initialize the game\r\ngenerateMaze();\r\npreviousPlayerPos = { x: player.x, y: player.y }; // Initialize previous position\r\nupdateHeartDisplay(); // Set initial heart display"
        }
    ]
}